#![allow(uncommon_codepoints)]

sanim::sanim! {
    ใช้ clap;
    ใช้ clap::Parser;
    ใช้ inline_colorization::*;
    ใช้ rand::Rng;
    ใช้ serde_json;
    ใช้ std::collections::HashMap;
    ใช้ std::error::Error;
    ใช้ std::fs::File;
    ใช้ std::io::{Read, Write};
    ใช้ std::path::PathBuf;

    #[ย่อย(clap::Parser, ดีบัก)]
    ชุดข้อมูล Cli {
        #[clap(short, long)]
        /// ชุดไฟล์คำศัพท์ใหม่
        คำศัพท์: เลือก<PathBuf>,
        #[clap(short, long, default_value_t = เท็จ)]
        /// ต่อคำศัพท์ไปยังชุดไฟล์คำศัพท์ (หากเป็นจริง จะต่อคำในชุดคำศัพท์เดิมถ้าคำศัพท์ใหม่มี ไม่งั้นจะเปลี่ยนชุดคำศัพท์เป็นคำศัพท์ใหม่) (ค่าเริ่มต้น: เท็จ)
        ต่อคำศัพท์: bool,
        #[clap(long, default_value_t = เท็จ)]
        /// โหมดยาก (ตัวอักษรสีเหลือง/เขียวจะต้องใช้ในการเดาคำถัดไปและตัวอักษรสีเขียวต้องอยู่ที่ตำแหน่งเดิม) (ค่าเริ่มต้น: เท็จ)
        ยาก: bool,
        #[clap(short, long, default_value_t = เท็จ)]
        /// เปลี่ยน words.json เป็น words.txt
        แปลงไฟล์คำศัพท์_json: bool,
    }

    ชุดข้อมูล คำศัพท์ {
        คำ: เวคเตอร์<สตริง>,
    }

    วิธี คำศัพท์ {
        #[อนุญาต(dead_code)]
        ฟังก์ชัน ใหม่() -> ตนเอง {
            ตนเอง { คำ: เวคเตอร์::ใหม่() }
        }
    
        ฟังก์ชัน โหลด(&แปรผัน ตน, เส้นทาง: PathBuf, ต่อ: bool) -> ผลลัพธ์<(), Box<พลวัต ข้อผิดพลาด>> {
            ให้ แปรผัน ไฟล์ = File::open(เส้นทาง)?;
            ให้ แปรผัน ข้อมูล = สตริง::ใหม่();
            ไฟล์.อ่านเป็นสตริง(&แปรผัน ข้อมูล)?;   
            ให้ แปรผัน คำ: เวคเตอร์<สตริง> = serde_json::from_str(&ข้อมูล)?;
            ถ้า ต่อ {
                ตน.คำ.append(&แปรผัน คำ);
            } ไม่งั้น {
                ตน.คำ = คำ;
            }
            โอเค(())
        }
    
        ฟังก์ชัน สุ่ม(&ตน) -> สตริง {
            ให้ แปรผัน สุ่ม = rand::thread_rng();
            ตน.คำ[สุ่ม.gen_range(0..ตน.คำ.len())].โคลน()
        }
    
        #[allow(non_snake_case)]
        ฟังก์ชัน มี(&ตน, คำ: &str) -> bool {
            ตน.คำ.contains(&คำ.เป็นสตริง())
        }
    }

    ชุดข้อมูล เกม {
        คำศัพท์: คำศัพท์,
        คำ: สตริง,
        เดา: เวคเตอร์<เวคเตอร์<เดา>>,
        ยาก: bool,
        กำลังเล่น: bool,
        จำนวนครั้ง: จำนวนเต็มไม่ลบ,
        จำนวนครั้งสูงสุด: จำนวนเต็มไม่ลบ,
        นับตัวอักษร: แฮชแมพ<char, จำนวนเต็ม>,
    }

    #[ย่อย(ดีบัก, โคลนนิ่ง, Copy, PartialEq, Eq)]
    แจกแจง เดา {
        ถูก(char),
        ผิด(char),
        พลาด(char),
    }

    วิธี เดา {
        ฟังก์ชัน เอาตัวอักษร(&ตน) -> char {
            จับคู่ ตน {
                เดา::ถูก(อักษร) => *อักษร,
                เดา::ผิด(อักษร) => *อักษร,
                เดา::พลาด(อักษร) => *อักษร,
            }
        }
    }

    วิธี ปริยาย สำหรับ คำศัพท์ {
        ฟังก์ชัน โดยปริยาย() -> ตนเอง {
            ให้ คำศัพท์ตั้งต้น: เวคเตอร์<สตริง> = serde_json::from_str(include_str!("../words.txt")).แกะ();
            ตนเอง { คำ: คำศัพท์ตั้งต้น }
        }
    }

    วิธี เกม {
        ฟังก์ชัน ใหม่(คำศัพท์: คำศัพท์, ยาก: bool) -> ตนเอง {
            ตนเอง {
                คำศัพท์,
                คำ: "".เป็นสตริง(),
                เดา: เวคเตอร์::ใหม่(),
                ยาก,
                กำลังเล่น: เท็จ,
                จำนวนครั้ง: 1,
                จำนวนครั้งสูงสุด: 5,
                นับตัวอักษร: แฮชแมพ::ใหม่(),
            }
        }
    
        ฟังก์ชัน เล่น(&แปรผัน ตน) -> สตริง {
            ตน.กำลังเล่น = จริง;
            ให้ คำ;
            ถ้า cfg!(debug_assertions) {
                คำ = "teats".เป็นสตริง();
            } ไม่งั้น {
                คำ = ตน.คำศัพท์.สุ่ม();
            }
            ตน.คำ = คำ.โคลน();
            ตน.นับตัวอักษร = คำ.chars().fold(แฮชแมพ::ใหม่(), |แปรผัน นับตัวอักษร, อักษร| {
                *นับตัวอักษร.entry(อักษร).or_insert(0) += 1;
                นับตัวอักษร
            });
            คำ
        }
    
        ฟังก์ชัน ตรวจสอบการเดา(&แปรผัน ตน, ข้อมูลเข้า: สตริง) -> ผลลัพธ์<เวคเตอร์<เดา>, ข้อผิดพลาดต่างๆ> {
            ถ้า ข้อมูลเข้า.len() != ตน.คำ.len() {
                ให้ผล พลาด(ข้อผิดพลาดต่างๆ::ความยางของคำไม่เท่ากับความยาวของคำที่ต้องเดา);
            }
            ถ้า !ตน.คำศัพท์.มี(&ข้อมูลเข้า) {
                ให้ผล พลาด(ข้อผิดพลาดต่างๆ::ไม่มีคำในชุดคำศัพท์);
            }
    
            ถ้า ตน.จำนวนครั้ง >= ตน.จำนวนครั้งสูงสุด {
                ให้ผล พลาด(ข้อผิดพลาดต่างๆ::หมดการพยายาม(ตน.คำ.โคลน(), ตน.เดา.โคลน()));
            }
            
            ถ้า ตน.ยาก && ตน.เดา.len() != 0 { // check ถ้า ใน ยาก mode and ถ้า already guessed a คำ
                ให้ เดาล่าสุด = ตน.เดา.last().แกะ();
                ให้ ตำแหน่งตัวอักษรที่ถูก = เดาล่าสุด.iter().enumerate().filter(|(_, c)| {
                    จับคู่ c {
                        เดา::ถูก(_) => จริง,
                        _ => เท็จ,
                    }
                }).map(|(ตำแหน่ง, อักษรเดา)| (ตำแหน่ง เป็น จำนวนเต็มไม่ลบ, อักษรเดา.เอาตัวอักษร())).เก็บเป็น::<เวคเตอร์<(จำนวนเต็มไม่ลบ, char)>>();
                ให้ ตัวอักษรที่พลาด = เดาล่าสุด.iter().filter(|c| {
                    จับคู่ c {
                        เดา::พลาด(_) => จริง,
                        _ => เท็จ,
                    }
                }).map(|i| i.เอาตัวอักษร()).เก็บเป็น::<เวคเตอร์<char>>();
                ให้ อักษรทั้งหมดในคำ = ข้อมูลเข้า.chars().เก็บเป็น::<เวคเตอร์<char>>();
                ถ้า !(ตำแหน่งตัวอักษรที่ถูก.len() == 0) {
                    สำหรับ (ตำแหน่ง, อักษร) ใน ตำแหน่งตัวอักษรที่ถูก {
                        ถ้า ให้ มี(อักษร2) = อักษรทั้งหมดในคำ.get(ตำแหน่ง เป็น usize) {
                            ถ้า อักษร2 != &อักษร {
                                ให้ผล พลาด(ข้อผิดพลาดต่างๆ::คำไม่ผ่านเกณฑ์โหมดยาก);
                            }
                        } ไม่งั้น {
                            ให้ผล พลาด(ข้อผิดพลาดต่างๆ::คำไม่ผ่านเกณฑ์โหมดยาก);
                        }
                    }
                    สำหรับ c ใน ตัวอักษรที่พลาด {
                        ถ้า !(อักษรทั้งหมดในคำ.contains(&c)) {
                            ให้ผล พลาด(ข้อผิดพลาดต่างๆ::คำไม่ผ่านเกณฑ์โหมดยาก);
                        }
                    }
                }
            }
        
            ให้ แปรผัน เดา = vec![เดา::ผิด('_'); ข้อมูลเข้า.len()];
            ให้ แปรผัน จำนวนตัวอักษรที่ถูก = 0;
            ให้ แปรผัน โคลนนับตัวอักษร = ตน.นับตัวอักษร.โคลน();
        
            สำหรับ (ตำแหน่ง, อักษร) ใน ข้อมูลเข้า.chars().enumerate() {
                ถ้า ตน.คำ.chars().nth(ตำแหน่ง).แกะ() == อักษร {
                    เดา[ตำแหน่ง] = เดา::ถูก(อักษร);
                    จำนวนตัวอักษรที่ถูก += 1;
                    โคลนนับตัวอักษร.entry(อักษร).and_modify(|x| *x -= 1);
                }
            }
        
            สำหรับ (ตำแหน่ง, อักษร) ใน ข้อมูลเข้า.chars().enumerate() {
                ถ้า เดา[ตำแหน่ง] == เดา::ผิด('_') { // Only check remaining letters
                    ถ้า ตน.คำ.contains(อักษร) && *โคลนนับตัวอักษร.entry(อักษร).or_insert(0) > 0 {
                        เดา[ตำแหน่ง] = เดา::พลาด(อักษร);
                        โคลนนับตัวอักษร.entry(อักษร).and_modify(|x| *x -= 1);
                    } ไม่งั้น {
                        เดา[ตำแหน่ง] = เดา::ผิด(อักษร);
                    }
                }
            }
        
            ตน.เดา.push(เดา.โคลน());
            ตน.จำนวนครั้ง += 1;
        
            ถ้า จำนวนตัวอักษรที่ถูก == ตน.คำ.len() {
                ตน.กำลังเล่น = เท็จ;
                ให้ โคลนเดา = ตน.เดา.โคลน();
                ให้ จำนวนครั้ง = ตน.จำนวนครั้ง;
                ให้ จำนวนครั้งสูงสุด = ตน.จำนวนครั้งสูงสุด;
                ตน.รีเซ็ต();
                ให้ผล พลาด(ข้อผิดพลาดต่างๆ::เกมจบชนะ(จำนวนครั้ง, จำนวนครั้งสูงสุด, โคลนเดา));
            }
            โอเค(เดา)
        }
        
        ฟังก์ชัน รีเซ็ต(&แปรผัน ตน) {
            ตน.จำนวนครั้ง = 1;
            ตน.เดา = เวคเตอร์::ใหม่();
            ตน.นับตัวอักษร = แฮชแมพ::ใหม่();
            ตน.คำ = "".เป็นสตริง();
        }
    }

    #[ย่อย(ดีบัก, โคลนนิ่ง)]
    enum ข้อผิดพลาดต่างๆ {
        ไม่มีคำในชุดคำศัพท์,
        ความยางของคำไม่เท่ากับความยาวของคำที่ต้องเดา,
        คำไม่ผ่านเกณฑ์โหมดยาก,
        หมดการพยายาม(สตริง,เวคเตอร์<เวคเตอร์<เดา>>),
        เกมจบชนะ(จำนวนเต็มไม่ลบ, จำนวนเต็มไม่ลบ, เวคเตอร์<เวคเตอร์<เดา>>)
    }

    impl ToString สำหรับ ข้อผิดพลาดต่างๆ {
        ฟังก์ชัน เป็นสตริง(&ตน) -> สตริง {
            จับคู่ ตน {
                ข้อผิดพลาดต่างๆ::ไม่มีคำในชุดคำศัพท์ => "No word found".เป็นสตริง(),
                ข้อผิดพลาดต่างๆ::ความยางของคำไม่เท่ากับความยาวของคำที่ต้องเดา => {
                    "Word length does not match the guess word length".เป็นสตริง()
                }
                ข้อผิดพลาดต่างๆ::คำไม่ผ่านเกณฑ์โหมดยาก => "Invalid word ใน hard mode".เป็นสตริง(),
                ข้อผิดพลาดต่างๆ::หมดการพยายาม(_, _) => "Maximum tries reached".เป็นสตริง(),
                ข้อผิดพลาดต่างๆ::เกมจบชนะ(_,_,_) => "Game ended with a win, please restart the game".เป็นสตริง(),
            }
        }
    }

    ฟังก์ชัน main() {
        better_panic::Settings::ใหม่()
            .lineno_suffix(จริง)
            .verbosity(better_panic::Verbosity::Full)
            .install();
    
        ให้ cli = Cli::parse();
        ให้ แปรผัน เกม = เกม::ใหม่(คำศัพท์::default(), cli.ยาก);
        ถ้า cli.แปลงไฟล์คำศัพท์_json {
            ให้ แปรผัน ไฟล์ = File::open("words.json").แกะ();
            ให้ แปรผัน ข้อมูล = สตริง::ใหม่();
            ไฟล์.อ่านเป็นสตริง(&แปรผัน ข้อมูล).แกะ();
            ให้ คำต่างๆ: แฮชแมพ<สตริง, u8> = serde_json::from_str(&ข้อมูล).แกะ();
            ให้ แปรผัน แปลงใหม่ = เวคเตอร์::ใหม่();
            สำหรับ (คำ, _) ใน คำต่างๆ {
                ถ้า คำ.len() == 5 {
                    แปลงใหม่.push(คำ);
                }
            }
            serde_json::to_writer_pretty(File::create("words.txt").แกะ(), &แปลงใหม่).แกะ();
            ให้ผล;
        }
    
        ถ้า ให้ มี(เส้นทาง) = cli.คำศัพท์ {
            เกม.คำศัพท์
                .โหลด(เส้นทาง, cli.ต่อคำศัพท์)
                .expect("Failed to load additonal word dictionary");
        }
        clearscreen::clear().ok();
        ช่วยเหลือ();
        วน {
            ให้ a = รับข้อมูลเข้า(มี("Selection > "));
            ถ้า a.to_lowercase() == "help" {
                ช่วยเหลือ();
            } ไม่งั้น ถ้า a.to_lowercase() == "play" {
                เล่น(&แปรผัน เกม);
            } ไม่งั้น ถ้า a.to_lowercase() == "options" {
                การตั้งค่า(&แปรผัน เกม);
            } ไม่งั้น ถ้า a.to_lowercase() == "exit" {
                ยกเลิก;
            } ไม่งั้น {
                พิมพ์บรรทัด!("No options found");
            }
        }
    }

    ฟังก์ชัน การตั้งค่า(เกม: &แปรผัน เกม) {
        วน {
            clearscreen::clear().ok();
            พิมพ์บรรทัด!("{color_cyan}R U D L E{color_reset}");
            พิมพ์บรรทัด!("Options:");
            พิมพ์บรรทัด!(
                "1. Append/Replace to word list ({} words)",
                เกม.คำศัพท์.คำ.len()
            );
            พิมพ์บรรทัด!("2. Hard mode (yellow/green letters will need to be used on next guess and green letters must stay where they are) ({})", ถ้า เกม.ยาก { "on" } ไม่งั้น { "off" });
            พิมพ์บรรทัด!("3. Tries ({} Tries)", เกม.จำนวนครั้งสูงสุด);
            พิมพ์บรรทัด!("4. Exit");
    
            ให้ ถาม = รับข้อมูลเข้า(มี("เลือก > "));
            ถ้า ถาม.to_lowercase() == "1" {
                ให้ ต่อหรือเปลี่่ยน =
                    จับคู่ รับข้อมูลเข้า(มี("Append or Replace to word list? (true/false) > "))
                        .to_lowercase()
                        .เป็นสตร()
                    {
                        "true" => จริง,
                        "false" => เท็จ,
                        _ => เท็จ,
                    };
                วน {
                    ให้ เส้นทาง = รับข้อมูลเข้า(มี("Append to word list (type q to exit) (File path required) > "));
                    ถ้า เส้นทาง.to_lowercase() == "q" {
                        ยกเลิก;
                    }
                    จับคู่ เกม
                        .คำศัพท์
                        .โหลด(PathBuf::from(เส้นทาง), ต่อหรือเปลี่่ยน)
                    {
                        โอเค(()) => {
                            พิมพ์บรรทัด!("{color_green}Loaded Successfully.{color_reset}");
                            ยกเลิก;
                        }
                        พลาด(e) => {
                            พิมพ์บรรทัด!(
                                "{color_red}Failed to load.{color_reset} ({})",
                                e.เป็นสตริง()
                            )
                        }
                    }
                }
            } ไม่งั้น ถ้า ถาม.to_lowercase() == "2" {
                เกม.ยาก = !เกม.ยาก;
                พิมพ์บรรทัด!("Hard mode is now {}", ถ้า เกม.ยาก { "on" } ไม่งั้น { "off" });
            } ไม่งั้น ถ้า ถาม.to_lowercase() == "3" {
                ให้ ครั้งสูงสุด = จับคู่ รับข้อมูลเข้า(มี("Tries (type q to use default) > ")).to_lowercase().เป็นสตร() {
                    "q" => 5,
                    _ => รับข้อมูลเข้า(มี("Tries (type q to use default) > ")).parse::<จำนวนเต็มไม่ลบ>().แกะ(),
                };
                เกม.จำนวนครั้งสูงสุด = ครั้งสูงสุด;
                พิมพ์บรรทัด!("Tries is now {}", ครั้งสูงสุด);
            } ไม่งั้น {
                ยกเลิก;
            }
        }
    }
    
    ฟังก์ชัน แสดงข้อความ(เกม: &เกม) {
        ถ้า cfg!(debug_assertions) {
            พิมพ์บรรทัด!("{color_cyan}R U D L E (Word is {}){color_reset}", เกม.คำ);
        } ไม่งั้น {
            พิมพ์บรรทัด!("{color_cyan}R U D L E (Word is {} characters long) {color_reset}", เกม.คำ.len());
        }
        พิมพ์บรรทัด!(
            "{}",
            เกม.เดา
                .iter()
                .map(|คำ| {
                    คำ.iter()
                        .map(|อักษร| จับคู่ อักษร {
                            เดา::ถูก(อักษร) => {
                                format!("{bg_green}{color_black}{}{color_reset}{bg_reset}", อักษร)
                            }
                            เดา::ผิด(อักษร) => {
                                format!("{bg_red}{color_black}{}{color_reset}{bg_reset}", อักษร)
                            }
                            เดา::พลาด(อักษร) => {
                                format!("{bg_yellow}{color_black}{}{color_reset}{bg_reset}", อักษร)
                            }
                        })
                        .เก็บเป็น()
                })
                .เก็บเป็น::<เวคเตอร์<เวคเตอร์<สตริง>>>()
                .iter()
                .map(|อักษรทั้งหมด| { อักษรทั้งหมด.join(" ") })
                .เก็บเป็น::<เวคเตอร์<สตริง>>()
                .join("\n\n")
        );
    }
    
    ฟังก์ชัน เล่น(เกม: &แปรผัน เกม) {
        เกม.เล่น();
        clearscreen::clear().ok();
        วน {
            ถ้า cfg!(debug_assertions) {
                พิมพ์บรรทัด!("{color_cyan}R U D L E (Word is {}) (Tries: {}/{} Tries{}){color_reset}", เกม.คำ, เกม.จำนวนครั้ง, เกม.จำนวนครั้งสูงสุด, ถ้า เกม.ยาก { " (Hard Mode)" } ไม่งั้น { "" });
            } ไม่งั้น {
                พิมพ์บรรทัด!("{color_cyan}R U D L E (Word is {} characters long) (Tries: {}/{} Tries{}){color_reset}", เกม.คำ.len(), เกม.จำนวนครั้ง, เกม.จำนวนครั้งสูงสุด, ถ้า เกม.ยาก { " (Hard Mode)" } ไม่งั้น { "" });
            }
            ให้ ข้อมูลเข้า = รับข้อมูลเข้า(มี("Guess  > "));
            ให้ เดา = เกม.ตรวจสอบการเดา(ข้อมูลเข้า);
            จับคู่ เดา {
                โอเค(_) => {
                    clearscreen::clear().ok();
                    แสดงข้อความ(เกม);
                    พิมพ์บรรทัด!();
                }
                #[allow(non_snake_case)]
                พลาด(ข้อผิดพลาด) => จับคู่ ข้อผิดพลาด {
                    ข้อผิดพลาดต่างๆ::หมดการพยายาม(คำ, เดา) => {
                        clearscreen::clear().ok();
                        แสดงข้อความ(เกม);
                        พิมพ์บรรทัด!("{color_yellow}Maximum tries reached, exiting...{color_reset}");
                        พิมพ์บรรทัด!("{color_red}The word  was {}{color_reset}", คำ);
                        พิมพ์บรรทัด!("{color_green}Your accuracy is {}%{color_reset}", คำนวณความถูกต้องของการเดา(เดา) * 100.0);
                        ยกเลิก;
                    },
                    ข้อผิดพลาดต่างๆ::เกมจบชนะ(จำนวนครั้ง, จำนวนครั้งสูงสุด, เดา) => {
                        พิมพ์บรรทัด!("{color_green}You win!{color_reset}");
                        พิมพ์บรรทัด!("{bg_black}{color_bright_white} Took {}/{} tries.{color_reset}{bg_reset}", จำนวนครั้ง - 1, จำนวนครั้งสูงสุด);
                        พิมพ์บรรทัด!("{color_green}Your accuracy is {}%{color_reset}", คำนวณความถูกต้องของการเดา(เดา.โคลน()) * 100.0);
                        ยกเลิก;
                    }
                    _ => {
                        พิมพ์บรรทัด!("{color_red}ERROR: {}{color_reset}", ข้อผิดพลาด.เป็นสตริง());
                    }
                },
            }
        }
    }
    
    ฟังก์ชัน คำนวณความถูกต้องของการเดา(เดา: เวคเตอร์<เวคเตอร์<เดา>>) -> ทศนิยม {
        ให้ แปรผัน คะแนน = 0.0;
        ให้ คะแนนที่มากที่สุด = เดา.first().แกะ().len() * 2; // 2 points per correct letter
        สำหรับ เดา ใน &เดา {
            สำหรับ g ใน เดา {
                ถ้า ให้ เดา::ถูก(_) = g { คะแนน += 2.0; }
                ไม่งั้น ถ้า ให้ เดา::พลาด(_) = g { คะแนน += 1.0; }
                ไม่งั้น {
                    คะแนน -= 0.5;
                }
            }
        }
        (คะแนน เป็น ทศนิยม / เดา.len() เป็น ทศนิยม) / คะแนนที่มากที่สุด เป็น ทศนิยม
    }
    
    ฟังก์ชัน ช่วยเหลือ() {
        พิมพ์บรรทัด!("{color_cyan}RUDLE{color_reset}");
        พิมพ์บรรทัด!(
            "Welcome to {color_cyan}RUDLE{color_reset}! Please run the program with {bg_black}{color_bright_white}-h{color_reset}{bg_reset} for additional flags like hard mode! (or you can manually configure this inside the game)" 
    );
        พิมพ์บรรทัด!(
            "Any configurable options can be changed with {bg_black}{color_bright_white}options{color_reset}{bg_reset} as the input!"
        );
        พิมพ์บรรทัด!(
            "And when you are ready to play, type {bg_black}{color_bright_white}play{color_reset}{bg_reset}!"
        );
    }
    
    ฟังก์ชัน รับข้อมูลเข้า(ถาม: เลือก<&str>) -> สตริง {
        พิมพ์!("{}", ถาม.unwrap_or(""));
        std::io::stdout().flush().แกะ();
        ให้ แปรผัน ข้อมูลเข้า = สตริง::ใหม่();
        std::io::stdin().read_line(&แปรผัน ข้อมูลเข้า).แกะ();
        ข้อมูลเข้า.trim_end().เป็นสตริง()
    }
}